diff --git a/libraries/chain/apply_context.cpp b/libraries/chain/apply_context.cpp
index dc7687cf0..34eed4e84 100644
--- a/libraries/chain/apply_context.cpp
+++ b/libraries/chain/apply_context.cpp
@@ -17,6 +17,10 @@ using boost::container::flat_set;
 namespace eosio { namespace chain {
 
 static inline void print_debug(account_name receiver, const action_trace& ar) {
+   if (eosio::chain::chain_config::deep_mind_console_enabled) {
+      return;
+   }
+
    if (!ar.console.empty()) {
       auto prefix = fc::format_string(
                                       "\n[(${a},${n})->${r}]",
@@ -168,9 +172,11 @@ void apply_context::exec()
 {
    _notified.emplace_back( receiver, action_ordinal );
    exec_one();
+   trx_context.action_id.increment();
    for( uint32_t i = 1; i < _notified.size(); ++i ) {
       std::tie( receiver, action_ordinal ) = _notified[i];
       exec_one();
+      trx_context.action_id.increment();
    }
 
    if( _cfa_inline_actions.size() > 0 || _inline_actions.size() > 0 ) {
@@ -233,6 +239,12 @@ void apply_context::require_recipient( account_name recipient ) {
          recipient,
          schedule_action( action_ordinal, recipient, false )
       );
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("CREATION_OP NOTIFY ${action_id}",
+            ("action_id", trx_context.action_id.current())
+         );
+      }
    }
 }
 
@@ -327,6 +339,12 @@ void apply_context::execute_inline( action&& a ) {
    _inline_actions.emplace_back(
       schedule_action( std::move(a), inline_receiver, false )
    );
+
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      dmlog("CREATION_OP INLINE ${action_id}",
+         ("action_id", trx_context.action_id.current())
+      );
+   }
 }
 
 void apply_context::execute_context_free_inline( action&& a ) {
@@ -342,6 +360,12 @@ void apply_context::execute_context_free_inline( action&& a ) {
    _cfa_inline_actions.emplace_back(
       schedule_action( std::move(a), inline_receiver, true )
    );
+
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      dmlog("CREATION_OP CFA_INLINE ${action_id}",
+         ("action_id", trx_context.action_id.current())
+      );
+   }
 }
 
 
@@ -463,21 +487,37 @@ void apply_context::schedule_deferred_transaction( const uint128_t& sender_id, a
    }
 
    uint32_t trx_size = 0;
+   fc::string event_id;
+   std::string operation;
    if ( auto ptr = db.find<generated_transaction_object,by_sender_id>(boost::make_tuple(receiver, sender_id)) ) {
       EOS_ASSERT( replace_existing, deferred_tx_duplicate, "deferred transaction with the same sender_id and payer already exists" );
 
       bool replace_deferred_activated = control.is_builtin_activated(builtin_protocol_feature_t::replace_deferred);
 
-      EOS_ASSERT( replace_deferred_activated || !control.is_producing_block()
-                     || control.all_subjective_mitigations_disabled(),
-                  subjective_block_production_exception,
-                  "Replacing a deferred transaction is temporarily disabled." );
+      // For the sake of testing Deep Mind, we would still like to replace a deferred
+      // transaction so we can later test that ram correction is correclty handled through
+      // Deep Mind code paths.
+      //
+      // However, when producing block, this is not possible anymore since v1.1.0. As such,
+      // if the `deep_mind_subjective_mitigations_disabled` is disabled, we lift the subjective
+      // mitigations and let our special producing node replace a deferred transaction.
+      //
+      if (!eosio::chain::chain_config::deep_mind_subjective_mitigations_disabled) {
+         EOS_ASSERT( replace_deferred_activated || !control.is_producing_block()
+                        || control.all_subjective_mitigations_disabled(),
+                     subjective_block_production_exception,
+                     "Replacing a deferred transaction is temporarily disabled." );
+      }
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         event_id = ramEventId("${id}", ("id", ptr->id));
+      }
 
       uint64_t orig_trx_ram_bytes = config::billable_size_v<generated_transaction_object> + ptr->packed_trx.size();
       if( replace_deferred_activated ) {
-         add_ram_usage( ptr->payer, -static_cast<int64_t>( orig_trx_ram_bytes ) );
+         add_ram_usage( ptr->payer, -static_cast<int64_t>( orig_trx_ram_bytes ), event_id.c_str(), "deferred_trx", "cancel", "deferred_trx_cancel" );
       } else {
-         control.add_to_ram_correction( ptr->payer, orig_trx_ram_bytes );
+         control.add_to_ram_correction( ptr->payer, orig_trx_ram_bytes, trx_context.action_id.current(), event_id.c_str() );
       }
 
       transaction_id_type trx_id_for_new_obj;
@@ -487,8 +527,27 @@ void apply_context::schedule_deferred_transaction( const uint128_t& sender_id, a
          trx_id_for_new_obj = ptr->trx_id;
       }
 
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         fc::datastream<const char*> ds( ptr->packed_trx.data(), ptr->packed_trx.size() );
+         transaction dtrx;
+         fc::raw::unpack(ds, static_cast<transaction&>(dtrx) );
+
+         dmlog("DTRX_OP MODIFY_CANCEL ${action_id} ${sender} ${sender_id} ${payer} ${published} ${delay} ${expiration} ${trx_id} ${trx}",
+            ("action_id", trx_context.action_id.current())
+            ("sender", receiver)
+            ("sender_id", sender_id)
+            ("payer", ptr->payer)
+            ("published", ptr->published)
+            ("delay", ptr->delay_until)
+            ("expiration", ptr->expiration)
+            ("trx_id", dtrx.id())
+            ("trx", control.to_variant_with_abi(dtrx, fc::microseconds(5000000)))
+         );
+      }
+
       // Use remove and create rather than modify because mutating the trx_id field in a modifier is unsafe.
       db.remove( *ptr );
+
       db.create<generated_transaction_object>( [&]( auto& gtx ) {
          gtx.trx_id      = trx_id_for_new_obj;
          gtx.sender      = receiver;
@@ -499,6 +558,23 @@ void apply_context::schedule_deferred_transaction( const uint128_t& sender_id, a
          gtx.expiration  = gtx.delay_until + fc::seconds(control.get_global_properties().configuration.deferred_trx_expiration_window);
 
          trx_size = gtx.set( trx );
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            operation = "update";
+            event_id = ramEventId("${id}", ("id", gtx.id));
+
+            dmlog("DTRX_OP MODIFY_CREATE ${action_id} ${sender} ${sender_id} ${payer} ${published} ${delay} ${expiration} ${trx_id} ${trx}",
+               ("action_id", trx_context.action_id.current())
+               ("sender", receiver)
+               ("sender_id", sender_id)
+               ("payer", payer)
+               ("published", gtx.published)
+               ("delay", gtx.delay_until)
+               ("expiration", gtx.expiration)
+               ("trx_id", trx.id())
+               ("trx", control.to_variant_with_abi(trx, fc::microseconds(5000000)))
+            );
+         }
       } );
    } else {
       db.create<generated_transaction_object>( [&]( auto& gtx ) {
@@ -511,6 +587,23 @@ void apply_context::schedule_deferred_transaction( const uint128_t& sender_id, a
          gtx.expiration  = gtx.delay_until + fc::seconds(control.get_global_properties().configuration.deferred_trx_expiration_window);
 
          trx_size = gtx.set( trx );
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            operation = "add";
+            event_id = ramEventId("${id}", ("id", gtx.id));
+
+            dmlog("DTRX_OP CREATE ${action_id} ${sender} ${sender_id} ${payer} ${published} ${delay} ${expiration} ${trx_id} ${trx}",
+               ("action_id", trx_context.action_id.current())
+               ("sender", receiver)
+               ("sender_id", sender_id)
+               ("payer", payer)
+               ("published", gtx.published)
+               ("delay", gtx.delay_until)
+               ("expiration", gtx.expiration)
+               ("trx_id", trx.id())
+               ("trx", control.to_variant_with_abi(trx, fc::microseconds(5000000)))
+            );
+         }
       } );
    }
 
@@ -520,14 +613,39 @@ void apply_context::schedule_deferred_transaction( const uint128_t& sender_id, a
                subjective_block_production_exception,
                "Cannot charge RAM to other accounts during notify."
    );
-   add_ram_usage( payer, (config::billable_size_v<generated_transaction_object> + trx_size) );
+   add_ram_usage( payer, (config::billable_size_v<generated_transaction_object> + trx_size), event_id.c_str(), "deferred_trx", operation.c_str(), "deferred_trx_add" );
 }
 
 bool apply_context::cancel_deferred_transaction( const uint128_t& sender_id, account_name sender ) {
+
+
    auto& generated_transaction_idx = db.get_mutable_index<generated_transaction_multi_index>();
    const auto* gto = db.find<generated_transaction_object,by_sender_id>(boost::make_tuple(sender, sender_id));
    if ( gto ) {
-      add_ram_usage( gto->payer, -(config::billable_size_v<generated_transaction_object> + gto->packed_trx.size()) );
+      fc::string event_id;
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         // unpack gtx->packed_trx into `dtrx` REVISE THIS!
+         auto gtx = generated_transaction(*gto);
+         fc::datastream<const char*> ds( gtx.packed_trx.data(), gtx.packed_trx.size() );
+         transaction dtrx;
+         fc::raw::unpack(ds, static_cast<transaction&>(dtrx) );
+
+         event_id = ramEventId("${id}", ("id", gto->id));
+
+         dmlog("DTRX_OP CANCEL ${action_id} ${sender} ${sender_id} ${payer} ${published} ${delay} ${expiration} ${trx_id} ${trx}",
+            ("action_id", trx_context.action_id.current())
+            ("sender", receiver)
+            ("sender_id", sender_id)
+            ("payer", gto->payer)
+            ("published", gto->published)
+            ("delay", gto->delay_until)
+            ("expiration", gto->expiration)
+            ("trx_id", dtrx.id())
+            ("trx", control.to_variant_with_abi(dtrx, fc::microseconds(5000000)))
+         );
+      }
+
+      add_ram_usage( gto->payer, -(config::billable_size_v<generated_transaction_object> + gto->packed_trx.size()), event_id.c_str(), "deferred_trx", "cancel", "deferred_trx_cancel" );
       generated_transaction_idx.remove(*gto);
    }
    return gto;
@@ -563,18 +681,57 @@ const table_id_object& apply_context::find_or_create_table( name code, name scop
       return *existing_tid;
    }
 
-   update_db_usage(payer, config::billable_size_v<table_id_object>);
+   fc::string event_id;
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      event_id = ramEventId("${code}:${scope}:${table}",
+         ("code", code)
+         ("scope", scope)
+         ("table", table)
+      );
+   }
+
+   update_db_usage(payer, config::billable_size_v<table_id_object>, event_id.c_str(), "table", "add", "create_table");
 
    return db.create<table_id_object>([&](table_id_object &t_id){
       t_id.code = code;
       t_id.scope = scope;
       t_id.table = table;
       t_id.payer = payer;
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("TBL_OP INS ${action_id} ${code} ${scope} ${table} ${payer}",
+            ("action_id", trx_context.action_id.current())
+            ("code", code)
+            ("scope", scope)
+            ("table", table)
+            ("payer", payer)
+         );
+      }
    });
 }
 
 void apply_context::remove_table( const table_id_object& tid ) {
-   update_db_usage(tid.payer, - config::billable_size_v<table_id_object>);
+   fc::string event_id;
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      event_id = ramEventId("${code}:${scope}:${table}",
+         ("code", tid.code)
+         ("scope", tid.scope)
+         ("table", tid.table)
+      );
+   }
+
+   update_db_usage(tid.payer, - config::billable_size_v<table_id_object>, event_id.c_str(), "table", "remove", "remove_table" );
+
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      dmlog("TBL_OP REM ${action_id} ${code} ${scope} ${table} ${payer}",
+         ("action_id", trx_context.action_id.current())
+         ("code", tid.code)
+         ("scope", tid.scope)
+         ("table", tid.table)
+         ("payer", tid.payer)
+      );
+   }
+
    db.remove(tid);
 }
 
@@ -593,7 +750,7 @@ bytes apply_context::get_packed_transaction() {
    return r;
 }
 
-void apply_context::update_db_usage( const account_name& payer, int64_t delta ) {
+void apply_context::update_db_usage( const account_name& payer, int64_t delta, const char* event_id, const char* family, const char* operation, const char* legacy_tag ) {
    if( delta > 0 ) {
       if( !(privileged || payer == account_name(receiver)
                || control.is_builtin_activated( builtin_protocol_feature_t::ram_restrictions ) ) )
@@ -603,7 +760,7 @@ void apply_context::update_db_usage( const account_name& payer, int64_t delta )
          require_authorization( payer );
       }
    }
-   add_ram_usage(payer, delta);
+   add_ram_usage(payer, delta, event_id, family, operation, legacy_tag);
 }
 
 
@@ -671,7 +828,30 @@ int apply_context::db_store_i64( uint64_t code, uint64_t scope, uint64_t table,
    });
 
    int64_t billable_size = (int64_t)(buffer_size + config::billable_size_v<key_value_object>);
-   update_db_usage( payer, billable_size);
+
+   fc::string event_id;
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      event_id = ramEventId("${table_code}:${scope}:${table_name}:${primkey}",
+         ("table_code", tab.code)
+         ("scope", tab.scope)
+         ("table_name", tab.table)
+         ("primkey", name(obj.primary_key))
+      );
+   }
+
+   update_db_usage( payer, billable_size, event_id.c_str(), "table_row", "add", "primary_index_add" );
+
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      dmlog("DB_OP INS ${action_id} ${payer} ${table_code} ${scope} ${table_name} ${primkey} ${ndata}",
+         ("action_id", trx_context.action_id.current())
+         ("payer", payer)
+         ("table_code", tab.code)
+         ("scope", tab.scope)
+         ("table_name", tab.table)
+         ("primkey", name(obj.primary_key))
+         ("ndata", to_hex(buffer, buffer_size))
+      );
+   }
 
    keyval_cache.cache_table( tab );
    return keyval_cache.add( obj );
@@ -691,14 +871,38 @@ void apply_context::db_update_i64( int iterator, account_name payer, const char*
 
    if( payer == account_name() ) payer = obj.payer;
 
+   fc::string event_id;
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      event_id = ramEventId("${table_code}:${scope}:${table_name}:${primkey}",
+         ("table_code", table_obj.code)
+         ("scope", table_obj.scope)
+         ("table_name", table_obj.table)
+         ("primkey", name(obj.primary_key))
+      );
+   }
+
    if( account_name(obj.payer) != payer ) {
       // refund the existing payer
-      update_db_usage( obj.payer,  -(old_size) );
+      update_db_usage( obj.payer, -(old_size), event_id.c_str(), "table_row", "remove", "primary_index_update_remove_old_payer" );
       // charge the new payer
-      update_db_usage( payer,  (new_size));
+      update_db_usage( payer,  (new_size), event_id.c_str(), "table_row", "add", "primary_index_update_add_new_payer" );
    } else if(old_size != new_size) {
       // charge/refund the existing payer the difference
-      update_db_usage( obj.payer, new_size - old_size);
+      update_db_usage( obj.payer, new_size - old_size, event_id.c_str() , "table_row", "update", "primary_index_update" );
+   }
+
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      dmlog("DB_OP UPD ${action_id} ${opayer}:${npayer} ${table_code} ${scope} ${table_name} ${primkey} ${odata}:${ndata}",
+         ("action_id", trx_context.action_id.current())
+         ("opayer", obj.payer)
+         ("npayer", payer)
+         ("table_code", table_obj.code)
+         ("scope", table_obj.scope)
+         ("table_name", table_obj.table)
+         ("primkey", name(obj.primary_key))
+         ("odata", to_hex(obj.value.data(),obj.value.size()))
+         ("ndata", to_hex(buffer, buffer_size))
+      );
    }
 
    db.modify( obj, [&]( auto& o ) {
@@ -715,7 +919,29 @@ void apply_context::db_remove_i64( int iterator ) {
 
 //   require_write_lock( table_obj.scope );
 
-   update_db_usage( obj.payer,  -(obj.value.size() + config::billable_size_v<key_value_object>) );
+   fc::string event_id;
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      event_id = ramEventId("${table_code}:${scope}:${table_name}:${primkey}",
+         ("table_code", table_obj.code)
+         ("scope", table_obj.scope)
+         ("table_name", table_obj.table)
+         ("primkey", name(obj.primary_key))
+      );
+   }
+
+   update_db_usage( obj.payer,  -(obj.value.size() + config::billable_size_v<key_value_object>), event_id.c_str(), "table_row", "remove", "primary_index_remove" );
+
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      dmlog("DB_OP REM ${action_id} ${payer} ${table_code} ${scope} ${table_name} ${primkey} ${odata}",
+         ("action_id", trx_context.action_id.current())
+         ("payer", obj.payer)
+         ("table_code", table_obj.code)
+         ("scope", table_obj.scope)
+         ("table_name", table_obj.table)
+         ("primkey", name(obj.primary_key))
+         ("odata", to_hex(obj.value.data(), obj.value.size()))
+      );
+   }
 
    db.modify( table_obj, [&]( auto& t ) {
       --t.count;
@@ -865,8 +1091,8 @@ uint64_t apply_context::next_auth_sequence( account_name actor ) {
    return amo.auth_sequence;
 }
 
-void apply_context::add_ram_usage( account_name account, int64_t ram_delta ) {
-   trx_context.add_ram_usage( account, ram_delta );
+void apply_context::add_ram_usage( account_name account, int64_t ram_delta, const char* event_id, const char* family, const char* operation, const char* legacy_tag ) {
+   trx_context.add_ram_usage( account, ram_delta, event_id, family, operation, legacy_tag );
 
    auto p = _account_ram_deltas.emplace( account, ram_delta );
    if( !p.second ) {
diff --git a/libraries/chain/authorization_manager.cpp b/libraries/chain/authorization_manager.cpp
index 83988c166..b3b1d5e38 100644
--- a/libraries/chain/authorization_manager.cpp
+++ b/libraries/chain/authorization_manager.cpp
@@ -137,6 +137,7 @@ namespace eosio { namespace chain {
                                                                       permission_name name,
                                                                       permission_id_type parent,
                                                                       const authority& auth,
+                                                                      uint32_t action_id,
                                                                       time_point initial_creation_time
                                                                     )
    {
@@ -149,21 +150,28 @@ namespace eosio { namespace chain {
          p.last_used = creation_time;
       });
 
-      const auto& perm = _db.create<permission_object>([&](auto& p) {
+      return _db.create<permission_object>([&](auto& p) {
          p.usage_id     = perm_usage.id;
          p.parent       = parent;
          p.owner        = account;
          p.name         = name;
          p.last_updated = creation_time;
          p.auth         = auth;
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog("PERM_OP INS ${action_id} ${data}",
+               ("action_id", action_id)
+               ("data", p)
+            );
+         }
       });
-      return perm;
    }
 
    const permission_object& authorization_manager::create_permission( account_name account,
                                                                       permission_name name,
                                                                       permission_id_type parent,
                                                                       authority&& auth,
+                                                                      uint32_t action_id,
                                                                       time_point initial_creation_time
                                                                     )
    {
@@ -176,31 +184,57 @@ namespace eosio { namespace chain {
          p.last_used = creation_time;
       });
 
-      const auto& perm = _db.create<permission_object>([&](auto& p) {
+      return _db.create<permission_object>([&](auto& p) {
          p.usage_id     = perm_usage.id;
          p.parent       = parent;
          p.owner        = account;
          p.name         = name;
          p.last_updated = creation_time;
          p.auth         = std::move(auth);
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog("PERM_OP INS ${action_id} ${data}",
+               ("action_id", action_id)
+               ("data", p)
+            );
+         }
       });
-      return perm;
    }
 
-   void authorization_manager::modify_permission( const permission_object& permission, const authority& auth ) {
+   void authorization_manager::modify_permission( const permission_object& permission, const authority& auth, uint32_t action_id) {
       _db.modify( permission, [&](permission_object& po) {
+         const permission_object old_permission(po);
+
          po.auth = auth;
          po.last_updated = _control.pending_block_time();
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog("PERM_OP UPD ${action_id} ${data}",
+               ("action_id", action_id)
+               ("data", fc::mutable_variant_object()
+                  ("old", old_permission)
+                  ("new", po)
+               )
+            );
+         }
       });
    }
 
-   void authorization_manager::remove_permission( const permission_object& permission ) {
+   void authorization_manager::remove_permission( const permission_object& permission, uint32_t action_id) {
       const auto& index = _db.template get_index<permission_index, by_parent>();
       auto range = index.equal_range(permission.id);
       EOS_ASSERT( range.first == range.second, action_validate_exception,
                   "Cannot remove a permission which has children. Remove the children first.");
 
       _db.get_mutable_index<permission_usage_index>().remove_object( permission.usage_id._id );
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("PERM_OP REM ${action_id} ${data}",
+              ("action_id", action_id)
+              ("data", permission)
+         );
+      }
+
       _db.remove( permission );
    }
 
diff --git a/libraries/chain/chain_config.cpp b/libraries/chain/chain_config.cpp
index 35c77f832..846884be2 100644
--- a/libraries/chain/chain_config.cpp
+++ b/libraries/chain/chain_config.cpp
@@ -8,6 +8,10 @@
 
 namespace eosio { namespace chain {
 
+   bool chain_config::deep_mind_enabled(false);
+   bool chain_config::deep_mind_console_enabled(false);
+   bool chain_config::deep_mind_subjective_mitigations_disabled(false);
+
    void chain_config::validate()const {
       EOS_ASSERT( target_block_net_usage_pct <= config::percent_100, action_validate_exception,
                   "target block net usage percentage cannot exceed 100%" );
diff --git a/libraries/chain/controller.cpp b/libraries/chain/controller.cpp
index 17e9c961c..9960b7429 100644
--- a/libraries/chain/controller.cpp
+++ b/libraries/chain/controller.cpp
@@ -30,6 +30,9 @@
 #include <fc/scoped_exit.hpp>
 #include <fc/variant_object.hpp>
 
+#include <boost/filesystem/path.hpp>
+namespace bfs = boost::filesystem;
+
 namespace eosio { namespace chain {
 
 using resource_limits::resource_limits_manager;
@@ -450,6 +453,26 @@ struct controller_impl {
    }
 
    void replay(std::function<bool()> shutdown) {
+      auto create_snapshot = [&](bfs::path snapshots_path) -> void {
+         auto head_id = head->id;
+         const auto& snapshot_path = snapshots_path / fc::format_string(
+            "snapshot-${id}.bin", fc::mutable_variant_object()("id", head_id)
+         );
+
+         auto snap_out = std::ofstream(snapshot_path.generic_string(), (std::ios::out | std::ios::binary));
+         auto writer = std::make_shared<ostream_snapshot_writer>(snap_out);
+
+         ilog( "creating snapshot ${head}-${id} (${path})",
+            ("head", head->block_num)
+            ("id", head->id)
+            ("path", snapshot_path.generic_string())
+         );
+         add_to_snapshot(writer);
+         writer->finalize();
+         snap_out.flush();
+         snap_out.close();
+      };
+
       auto blog_head = blog.head();
       auto blog_head_time = blog_head->timestamp.to_time_point();
       replay_head_time = blog_head_time;
@@ -464,6 +487,17 @@ struct controller_impl {
          try {
             while( auto next = blog.read_block_by_num( head->block_num + 1 ) ) {
                replay_push_block( next, controller::block_status::irreversible );
+
+               if (conf.schnapps_enable) {
+                  if( next->block_num() % conf.schnapps_block_interval == 0 ||
+                     next->block_num() == 176 || next->block_num() == 214
+
+                     // next->block_num() == 53701 || next->block_num() == 103611 || next->block_num() == 154656 || next->block_num() == 251684 || next->block_num() ==  303009
+                  ) {
+                     create_snapshot(conf.schnapps_snapshots_path);
+                  }
+               }
+
                if( next->block_num() % 500 == 0 ) {
                   ilog( "${n} of ${head}", ("n", next->block_num())("head", blog_head->block_num()) );
                   if( shutdown() ) break;
@@ -879,9 +913,9 @@ struct controller_impl {
       });
 
       const auto& owner_permission  = authorization.create_permission(name, config::owner_name, 0,
-                                                                      owner, conf.genesis.initial_timestamp );
+                                                                      owner, 0, conf.genesis.initial_timestamp );
       const auto& active_permission = authorization.create_permission(name, config::active_name, owner_permission.id,
-                                                                      active, conf.genesis.initial_timestamp );
+                                                                      active, 0, conf.genesis.initial_timestamp );
 
       resource_limits.initialize_account(name);
 
@@ -890,7 +924,12 @@ struct controller_impl {
       ram_delta += owner_permission.auth.get_billable_size();
       ram_delta += active_permission.auth.get_billable_size();
 
-      resource_limits.add_pending_ram_usage(name, ram_delta);
+      fc::string event_id;
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         event_id = ramEventId("${name}", ("name", name));
+      }
+
+      resource_limits.add_pending_ram_usage(name, ram_delta, 0, event_id.c_str(), "account", "add", "newaccount");
       resource_limits.verify_account_ram_usage(name);
    }
 
@@ -935,11 +974,13 @@ struct controller_impl {
                                                                              config::majority_producers_permission_name,
                                                                              active_permission.id,
                                                                              active_producers_authority,
+                                                                             0,
                                                                              conf.genesis.initial_timestamp );
       const auto& minority_permission     = authorization.create_permission( config::producers_account_name,
                                                                              config::minority_producers_permission_name,
                                                                              majority_permission.id,
                                                                              active_producers_authority,
+                                                                             0,
                                                                              conf.genesis.initial_timestamp );
    }
 
@@ -986,6 +1027,13 @@ struct controller_impl {
          etrx.set_reference_block( self.head_block_id() );
       }
 
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("TRX_OP CREATE onerror ${id} ${trx}",
+            ("id", etrx.id())
+            ("trx", self.to_variant_with_abi(etrx, fc::microseconds(5000000)))
+         );
+      }
+
       transaction_context trx_context( self, etrx, etrx.id(), start );
       trx_context.deadline = deadline;
       trx_context.explicit_billed_cpu_time = explicit_billed_cpu_time;
@@ -1020,8 +1068,13 @@ struct controller_impl {
    }
 
    int64_t remove_scheduled_transaction( const generated_transaction_object& gto ) {
+      fc::string event_id;
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         event_id = ramEventId("${id}", ("id", gto.id));
+      }
+
       int64_t ram_delta = -(config::billable_size_v<generated_transaction_object> + gto.packed_trx.size());
-      resource_limits.add_pending_ram_usage( gto.payer, ram_delta );
+      resource_limits.add_pending_ram_usage( gto.payer, ram_delta, 0, event_id.c_str(), "deferred_trx", "remove", "deferred_trx_removed" );
       // No need to verify_account_ram_usage since we are only reducing memory
 
       db.remove( gto );
@@ -1161,6 +1214,12 @@ struct controller_impl {
          trace->except = e;
          trace->except_ptr = std::current_exception();
          trace->elapsed = fc::time_point::now() - trx_context.start;
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog("DTRX_OP FAILED ${action_id}",
+               ("action_id", trx_context.action_id.current())
+            );
+         }
       }
       trx_context.undo();
 
@@ -1374,6 +1433,11 @@ struct controller_impl {
                      controller::block_status s,
                      const optional<block_id_type>& producer_block_id )
    {
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         // The head block represents the block just before this on that is about to start, so add 1 to get this block num
+         dmlog("START_BLOCK ${block_num}", ("block_num", head->block_num + 1));
+      }
+
       EOS_ASSERT( !pending, block_validate_exception, "pending block already exists" );
 
       auto guard_pending = fc::make_scoped_exit([this, head_block_num=head->block_num](){
@@ -1893,6 +1957,14 @@ struct controller_impl {
          auto old_head = head;
          ilog("switching forks from ${current_head_id} (block number ${current_head_num}) to ${new_head_id} (block number ${new_head_num})",
               ("current_head_id", head->id)("current_head_num", head->block_num)("new_head_id", new_head->id)("new_head_num", new_head->block_num) );
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog("SWITCH_FORK ${from_id} ${to_id}",
+               ("from_id", head->id)
+               ("to_id", new_head->id)
+            );
+         }
+
          auto branches = fork_db.fetch_branch_from( new_head->id, head->id );
 
          if( branches.second.size() > 0 ) {
@@ -2205,6 +2277,14 @@ struct controller_impl {
          trx.expiration = self.pending_block_time() + fc::microseconds(999'999); // Round up to nearest second to avoid appearing expired
          trx.set_reference_block( self.head_block_id() );
       }
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("TRX_OP CREATE onblock ${id} ${trx}",
+            ("id", trx.id())
+            ("trx", self.to_variant_with_abi(trx, fc::microseconds(5000000)))
+         );
+      }
+
       return trx;
    }
 
@@ -2279,7 +2359,7 @@ chainbase::database& controller::mutable_db()const { return my->db; }
 
 const fork_database& controller::fork_db()const { return my->fork_db; }
 
-void controller::preactivate_feature( const digest_type& feature_digest ) {
+void controller::preactivate_feature( uint32_t action_id, const digest_type& feature_digest ) {
    const auto& pfs = my->protocol_features.get_protocol_feature_set();
    auto cur_time = pending_block_time();
 
@@ -2376,6 +2456,16 @@ void controller::preactivate_feature( const digest_type& feature_digest ) {
                ("digest", feature_digest)
    );
 
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      const auto feature = pfs.get_protocol_feature(feature_digest);
+
+      dmlog("FEATURE_OP PRE_ACTIVATE ${action_id} ${feature_digest} ${feature}",
+         ("action_id", action_id)
+         ("feature_digest", feature_digest)
+         ("feature", feature.to_variant())
+      );
+   }
+
    my->db.modify( pso, [&]( auto& ps ) {
       ps.preactivated_protocol_features.push_back( feature_digest );
    } );
@@ -3019,17 +3109,31 @@ const flat_set<account_name> &controller::get_resource_greylist() const {
 }
 
 
-void controller::add_to_ram_correction( account_name account, uint64_t ram_bytes ) {
+void controller::add_to_ram_correction( account_name account, uint64_t ram_bytes, uint32_t action_id, const char* event_id ) {
+   int64_t correction_object_id = 0;
+
    if( auto ptr = my->db.find<account_ram_correction_object, by_name>( account ) ) {
       my->db.modify<account_ram_correction_object>( *ptr, [&]( auto& rco ) {
+         correction_object_id = rco.id._id;
          rco.ram_correction += ram_bytes;
       } );
    } else {
       my->db.create<account_ram_correction_object>( [&]( auto& rco ) {
+         correction_object_id = rco.id._id;
          rco.name = account;
          rco.ram_correction = ram_bytes;
       } );
    }
+
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      dmlog("RAM_CORRECTION_OP ${action_id} ${correction_id} ${event_id} ${payer} ${delta}",
+         ("action_id", action_id)
+         ("correction_id", correction_object_id)
+         ("event_id", event_id)
+         ("payer", account)
+         ("delta", ram_bytes)
+      );
+   }
 }
 
 bool controller::all_subjective_mitigations_disabled()const {
@@ -3075,7 +3179,12 @@ void controller_impl::on_activation<builtin_protocol_feature_t::replace_deferred
                ("name", itr->name)("adjust", itr->ram_correction)("current", current_ram_usage) );
       }
 
-      resource_limits.add_pending_ram_usage( itr->name, ram_delta );
+      fc::string event_id;
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         event_id = ramEventId("${id}", ("id", itr->id._id));
+      }
+
+      resource_limits.add_pending_ram_usage( itr->name, ram_delta, 0, event_id.c_str(), "deferred_trx", "correction", "deferred_trx_ram_correction" );
       db.remove( *itr );
    }
 }
diff --git a/libraries/chain/eosio_contract.cpp b/libraries/chain/eosio_contract.cpp
index 9bd9a022f..8f7f6eaf7 100644
--- a/libraries/chain/eosio_contract.cpp
+++ b/libraries/chain/eosio_contract.cpp
@@ -110,9 +110,9 @@ void apply_eosio_newaccount(apply_context& context) {
    }
 
    const auto& owner_permission  = authorization.create_permission( create.name, config::owner_name, 0,
-                                                                    std::move(create.owner) );
+                                                                    std::move(create.owner), context.trx_context.action_id.current() );
    const auto& active_permission = authorization.create_permission( create.name, config::active_name, owner_permission.id,
-                                                                    std::move(create.active) );
+                                                                    std::move(create.active), context.trx_context.action_id.current() );
 
    context.control.get_mutable_resource_limits_manager().initialize_account(create.name);
 
@@ -121,7 +121,12 @@ void apply_eosio_newaccount(apply_context& context) {
    ram_delta += owner_permission.auth.get_billable_size();
    ram_delta += active_permission.auth.get_billable_size();
 
-   context.add_ram_usage(create.name, ram_delta);
+   fc::string event_id;
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      event_id = ramEventId("${name}", ("name", create.name));
+   }
+
+   context.add_ram_usage(create.name, ram_delta, event_id.c_str(), "account", "add", "newaccount");
 
 } FC_CAPTURE_AND_RETHROW( (create) ) }
 
@@ -195,7 +200,20 @@ void apply_eosio_setcode(apply_context& context) {
    });
 
    if (new_size != old_size) {
-      context.add_ram_usage( act.account, new_size - old_size );
+      std::string operation;
+      fc::string event_id;
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         operation = "update";
+         if (old_size <= 0) {
+            operation = "add";
+         } else if (new_size <= 0) {
+            operation = "remove";
+         }
+
+         event_id = ramEventId("${account}", ("account", act.account));
+      }
+
+      context.add_ram_usage( act.account, new_size - old_size, event_id.c_str(), "code", operation.c_str(), "setcode" );
    }
 }
 
@@ -226,7 +244,20 @@ void apply_eosio_setabi(apply_context& context) {
    });
 
    if (new_size != old_size) {
-      context.add_ram_usage( act.account, new_size - old_size );
+      std::string operation;
+      fc::string event_id;
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         operation = "update";
+         if (old_size <= 0) {
+            operation = "add";
+         } else if (new_size <= 0) {
+            operation = "remove";
+         }
+
+         event_id = ramEventId("${account}", ("account", act.account));
+      }
+
+      context.add_ram_usage( act.account, new_size - old_size, event_id.c_str(), "abi", operation.c_str(), "setabi" );
    }
 }
 
@@ -280,17 +311,27 @@ void apply_eosio_updateauth(apply_context& context) {
 
       int64_t old_size = (int64_t)(config::billable_size_v<permission_object> + permission->auth.get_billable_size());
 
-      authorization.modify_permission( *permission, update.auth );
+      authorization.modify_permission( *permission, update.auth, context.trx_context.action_id.current() );
 
       int64_t new_size = (int64_t)(config::billable_size_v<permission_object> + permission->auth.get_billable_size());
 
-      context.add_ram_usage( permission->owner, new_size - old_size );
+      fc::string event_id;
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         event_id = ramEventId("${id}", ("id", permission->id));
+      }
+
+      context.add_ram_usage( permission->owner, new_size - old_size, event_id.c_str(), "auth", "update", "updateauth_update" );
    } else {
-      const auto& p = authorization.create_permission( update.account, update.permission, parent_id, update.auth );
+      const auto& p = authorization.create_permission( update.account, update.permission, parent_id, update.auth, context.trx_context.action_id.current() );
 
       int64_t new_size = (int64_t)(config::billable_size_v<permission_object> + p.auth.get_billable_size());
 
-      context.add_ram_usage( update.account, new_size );
+      fc::string event_id;
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         event_id = ramEventId("${id}", ("id", p.id));
+      }
+
+      context.add_ram_usage( update.account, new_size, event_id.c_str(), "auth", "add", "updateauth_create" );
    }
 }
 
@@ -319,10 +360,14 @@ void apply_eosio_deleteauth(apply_context& context) {
    const auto& permission = authorization.get_permission({remove.account, remove.permission});
    int64_t old_size = config::billable_size_v<permission_object> + permission.auth.get_billable_size();
 
-   authorization.remove_permission( permission );
+   fc::string event_id;
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      event_id = ramEventId("${id}", ("id", permission.id));
+   }
 
-   context.add_ram_usage( remove.account, -old_size );
+   authorization.remove_permission( permission, context.trx_context.action_id.current() );
 
+   context.add_ram_usage( remove.account, -old_size, event_id.c_str(), "auth", "remove", "deleteauth" );
 }
 
 void apply_eosio_linkauth(apply_context& context) {
@@ -372,9 +417,18 @@ void apply_eosio_linkauth(apply_context& context) {
             link.required_permission = requirement.requirement;
          });
 
+         fc::string event_id;
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            event_id = ramEventId("${id}", ("id", l.id));
+         }
+
          context.add_ram_usage(
             l.account,
-            (int64_t)(config::billable_size_v<permission_link_object>)
+            (int64_t)(config::billable_size_v<permission_link_object>),
+            event_id.c_str(),
+            "auth_link",
+            "add",
+            "linkauth"
          );
       }
 
@@ -392,9 +446,19 @@ void apply_eosio_unlinkauth(apply_context& context) {
    auto link_key = boost::make_tuple(unlink.account, unlink.code, unlink.type);
    auto link = db.find<permission_link_object, by_action_name>(link_key);
    EOS_ASSERT(link != nullptr, action_validate_exception, "Attempting to unlink authority, but no link found");
+
+   fc::string event_id;
+   if (eosio::chain::chain_config::deep_mind_enabled) {
+      event_id = ramEventId("${id}", ("id", link->id));
+   }
+
    context.add_ram_usage(
       link->account,
-      -(int64_t)(config::billable_size_v<permission_link_object>)
+      -(int64_t)(config::billable_size_v<permission_link_object>),
+      event_id.c_str(),
+      "auth_link",
+      "remove",
+      "unlinkauth"
    );
 
    db.remove(*link);
diff --git a/libraries/chain/include/eosio/chain/apply_context.hpp b/libraries/chain/include/eosio/chain/apply_context.hpp
index ce7ae2bda..0906dafbd 100644
--- a/libraries/chain/include/eosio/chain/apply_context.hpp
+++ b/libraries/chain/include/eosio/chain/apply_context.hpp
@@ -193,11 +193,21 @@ class apply_context {
                   o.payer         = payer;
                });
 
+               fc::string event_id;
                context.db.modify( tab, [&]( auto& t ) {
                  ++t.count;
+
+                  if (eosio::chain::chain_config::deep_mind_enabled) {
+                     event_id = ramEventId("${code}:${scope}:${table}:${index_name}",
+                        ("code", t.code)
+                        ("scope", t.scope)
+                        ("table", t.table)
+                        ("index_name", name(id))
+                     );
+                  }
                });
 
-               context.update_db_usage( payer, config::billable_size_v<ObjectType> );
+               context.update_db_usage( payer, config::billable_size_v<ObjectType>, event_id.c_str(), "secondary_index", "add", "secondary_index_add" );
 
                itr_cache.cache_table( tab );
                return itr_cache.add( obj );
@@ -205,11 +215,22 @@ class apply_context {
 
             void remove( int iterator ) {
                const auto& obj = itr_cache.get( iterator );
-               context.update_db_usage( obj.payer, -( config::billable_size_v<ObjectType> ) );
 
                const auto& table_obj = itr_cache.get_table( obj.t_id );
                EOS_ASSERT( table_obj.code == context.receiver, table_access_violation, "db access violation" );
 
+               fc::string event_id;
+               if (eosio::chain::chain_config::deep_mind_enabled) {
+                  event_id = ramEventId("${code}:${scope}:${table}:${index_name}",
+                     ("code", table_obj.code)
+                     ("scope", table_obj.scope)
+                     ("table", table_obj.table)
+                     ("index_name", name(obj.primary_key))
+                  );
+               }
+
+               context.update_db_usage( obj.payer, -( config::billable_size_v<ObjectType> ), event_id.c_str(), "secondary_index", "remove", "secondary_index_remove" );
+
 //               context.require_write_lock( table_obj.scope );
 
                context.db.modify( table_obj, [&]( auto& t ) {
@@ -236,9 +257,19 @@ class apply_context {
 
                int64_t billing_size =  config::billable_size_v<ObjectType>;
 
+               fc::string event_id;
+               if (eosio::chain::chain_config::deep_mind_enabled) {
+                  event_id = ramEventId("${code}:${scope}:${table}:${index_name}",
+                     ("code", table_obj.code)
+                     ("scope", table_obj.scope)
+                     ("table", table_obj.table)
+                     ("index_name", name(obj.primary_key))
+                  );
+               }
+
                if( obj.payer != payer ) {
-                  context.update_db_usage( obj.payer, -(billing_size) );
-                  context.update_db_usage( payer, +(billing_size) );
+                  context.update_db_usage( obj.payer, -(billing_size), event_id.c_str(), "secondary_index", "remove", "secondary_index_update_remove_old_payer" );
+                  context.update_db_usage( payer, +(billing_size), event_id.c_str(), "secondary_index", "add", "secondary_index_update_add_new_payer" );
                }
 
                context.db.modify( obj, [&]( auto& o ) {
@@ -512,7 +543,7 @@ class apply_context {
    /// Database methods:
    public:
 
-      void update_db_usage( const account_name& payer, int64_t delta );
+      void update_db_usage( const account_name& payer, int64_t delta, const char* event_id, const char* family, const char* operation, const char* legacy_tag );
 
       int  db_store_i64( uint64_t scope, uint64_t table, const account_name& payer, uint64_t id, const char* buffer, size_t buffer_size );
       void db_update_i64( int iterator, account_name payer, const char* buffer, size_t buffer_size );
@@ -546,7 +577,7 @@ class apply_context {
       uint64_t next_recv_sequence( const account_metadata_object& receiver_account );
       uint64_t next_auth_sequence( account_name actor );
 
-      void add_ram_usage( account_name account, int64_t ram_delta );
+      void add_ram_usage( account_name account, int64_t ram_delta, const char* event_id, const char* family, const char* operation, const char* legacy_tag );
       void finalize_trace( action_trace& trace, const fc::time_point& start );
 
       bool is_context_free()const { return context_free; }
diff --git a/libraries/chain/include/eosio/chain/authorization_manager.hpp b/libraries/chain/include/eosio/chain/authorization_manager.hpp
index 3e9ffd0bb..7fbc6628c 100644
--- a/libraries/chain/include/eosio/chain/authorization_manager.hpp
+++ b/libraries/chain/include/eosio/chain/authorization_manager.hpp
@@ -35,6 +35,7 @@ namespace eosio { namespace chain {
                                                      permission_name name,
                                                      permission_id_type parent,
                                                      const authority& auth,
+                                                     uint32_t action_id,
                                                      time_point initial_creation_time = time_point()
                                                    );
 
@@ -42,12 +43,13 @@ namespace eosio { namespace chain {
                                                      permission_name name,
                                                      permission_id_type parent,
                                                      authority&& auth,
+                                                     uint32_t action_id,
                                                      time_point initial_creation_time = time_point()
                                                    );
 
-         void modify_permission( const permission_object& permission, const authority& auth );
+         void modify_permission( const permission_object& permission, const authority& auth, uint32_t action_id );
 
-         void remove_permission( const permission_object& permission );
+         void remove_permission( const permission_object& permission, uint32_t action_id );
 
          void update_permission_usage( const permission_object& permission );
 
@@ -119,7 +121,7 @@ namespace eosio { namespace chain {
          static std::function<void()> _noop_checktime;
 
       private:
-         const controller&    _control;
+         controller&    _control;
          chainbase::database& _db;
 
          void             check_updateauth_authorization( const updateauth& update, const vector<permission_level>& auths )const;
diff --git a/libraries/chain/include/eosio/chain/chain_config.hpp b/libraries/chain/include/eosio/chain/chain_config.hpp
index 37b73cb51..5296634ea 100644
--- a/libraries/chain/include/eosio/chain/chain_config.hpp
+++ b/libraries/chain/include/eosio/chain/chain_config.hpp
@@ -17,6 +17,10 @@ namespace eosio { namespace chain {
  * values specified by the producers.
  */
 struct chain_config {
+   static bool deep_mind_enabled;
+   static bool deep_mind_console_enabled;
+   static bool deep_mind_subjective_mitigations_disabled;
+
    uint64_t   max_block_net_usage;                 ///< the maxiumum net usage in instructions for a block
    uint32_t   target_block_net_usage_pct;          ///< the target percent (1% == 100, 100%= 10,000) of maximum net usage; exceeding this triggers congestion handling
    uint32_t   max_transaction_net_usage;           ///< the maximum objectively measured net usage that the chain will allow regardless of account limits
diff --git a/libraries/chain/include/eosio/chain/controller.hpp b/libraries/chain/include/eosio/chain/controller.hpp
index c7702d094..b3254d84b 100644
--- a/libraries/chain/include/eosio/chain/controller.hpp
+++ b/libraries/chain/include/eosio/chain/controller.hpp
@@ -78,6 +78,10 @@ namespace eosio { namespace chain {
             bool                     allow_ram_billing_in_notify = false;
             bool                     disable_all_subjective_mitigations = false; //< for testing purposes only
 
+            bool                     schnapps_enable = false;
+            uint32_t                 schnapps_block_interval = 50000;
+            path                     schnapps_snapshots_path = ".";
+
             genesis_state            genesis;
             wasm_interface::vm_type  wasm_runtime = chain::config::default_wasm_runtime;
 
@@ -105,7 +109,7 @@ namespace eosio { namespace chain {
          void add_indices();
          void startup( std::function<bool()> shutdown, const snapshot_reader_ptr& snapshot = nullptr );
 
-         void preactivate_feature( const digest_type& feature_digest );
+         void preactivate_feature( uint32_t action_id, const digest_type& feature_digest );
 
          vector<digest_type> get_preactivated_protocol_features()const;
 
@@ -272,7 +276,7 @@ namespace eosio { namespace chain {
 
          void set_subjective_cpu_leeway(fc::microseconds leeway);
 
-         void add_to_ram_correction( account_name account, uint64_t ram_bytes );
+         void add_to_ram_correction( account_name account, uint64_t ram_bytes, uint32_t action_id, const char* event_id );
          bool all_subjective_mitigations_disabled()const;
 
          static fc::optional<uint64_t> convert_exception_to_error_code( const fc::exception& e );
diff --git a/libraries/chain/include/eosio/chain/resource_limits.hpp b/libraries/chain/include/eosio/chain/resource_limits.hpp
index 08d1d1f7c..1206e4abf 100644
--- a/libraries/chain/include/eosio/chain/resource_limits.hpp
+++ b/libraries/chain/include/eosio/chain/resource_limits.hpp
@@ -1,4 +1,5 @@
 #pragma once
+#include <eosio/chain/chain_config.hpp>
 #include <eosio/chain/exceptions.hpp>
 #include <eosio/chain/types.hpp>
 #include <eosio/chain/snapshot.hpp>
@@ -70,7 +71,7 @@ namespace eosio { namespace chain { namespace resource_limits {
          void update_account_usage( const flat_set<account_name>& accounts, uint32_t ordinal );
          void add_transaction_usage( const flat_set<account_name>& accounts, uint64_t cpu_usage, uint64_t net_usage, uint32_t ordinal );
 
-         void add_pending_ram_usage( const account_name account, int64_t ram_delta );
+         void add_pending_ram_usage( const account_name account, int64_t ram_delta, uint32_t action_id, const char* event_id, const char* family, const char* operation, const char* legacy_tag );
          void verify_account_ram_usage( const account_name accunt )const;
 
          /// set_account_limits returns true if new ram_bytes limit is more restrictive than the previously set one
diff --git a/libraries/chain/include/eosio/chain/transaction_context.hpp b/libraries/chain/include/eosio/chain/transaction_context.hpp
index a799d6771..2fdcc442d 100644
--- a/libraries/chain/include/eosio/chain/transaction_context.hpp
+++ b/libraries/chain/include/eosio/chain/transaction_context.hpp
@@ -5,6 +5,18 @@
 
 namespace eosio { namespace chain {
 
+   class action_id {
+      public:
+        action_id(): id(0) {}
+
+        inline void increment() { id++; }
+        inline uint32_t current() { return id; }
+
+      private:
+        uint32_t id;
+   };
+
+
    struct deadline_timer {
          deadline_timer();
          ~deadline_timer();
@@ -62,7 +74,7 @@ namespace eosio { namespace chain {
          friend struct controller_impl;
          friend class apply_context;
 
-         void add_ram_usage( account_name account, int64_t ram_delta );
+         void add_ram_usage( account_name account, int64_t ram_delta, const char* event_id, const char* family, const char* operation, const char* legacy_tag );
 
          action_trace& get_action_trace( uint32_t action_ordinal );
          const action_trace& get_action_trace( uint32_t action_ordinal )const;
@@ -118,6 +130,8 @@ namespace eosio { namespace chain {
          int64_t                       billed_cpu_time_us = 0;
          bool                          explicit_billed_cpu_time = false;
 
+         /// kept to track ids of action_traces push via this transaction
+         action_id                     action_id;
       private:
          bool                          is_initialized = false;
 
diff --git a/libraries/chain/include/eosio/chain/types.hpp b/libraries/chain/include/eosio/chain/types.hpp
index d6323fbd2..4d8cc0d8d 100644
--- a/libraries/chain/include/eosio/chain/types.hpp
+++ b/libraries/chain/include/eosio/chain/types.hpp
@@ -28,6 +28,9 @@
 #include <deque>
 #include <cstdint>
 
+#define ramEventId( FORMAT, ... ) \
+   fc::format_string( FORMAT, fc::mutable_variant_object()__VA_ARGS__ )
+
 #define OBJECT_CTOR1(NAME) \
     NAME() = delete; \
     public: \
diff --git a/libraries/chain/protocol_feature_manager.cpp b/libraries/chain/protocol_feature_manager.cpp
index ca0457ce1..38a464a1d 100644
--- a/libraries/chain/protocol_feature_manager.cpp
+++ b/libraries/chain/protocol_feature_manager.cpp
@@ -3,6 +3,7 @@
  *  @copyright defined in eos/LICENSE
  */
 
+#include <eosio/chain/chain_config.hpp>
 #include <eosio/chain/protocol_feature_manager.hpp>
 #include <eosio/chain/protocol_state_object.hpp>
 #include <eosio/chain/exceptions.hpp>
@@ -644,6 +645,13 @@ either the account authorized the action or the action's net effect on RAM usage
                   ("digest", feature_digest)
       );
 
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("FEATURE_OP ACTIVATE ${feature_digest} ${feature}",
+            ("feature_digest", feature_digest)
+            ("feature", itr->to_variant())
+         );
+      }
+
       _activated_protocol_features.push_back( protocol_feature_entry{itr, current_block_num} );
       _builtin_protocol_features[indx].previous = _head_of_builtin_activation_list;
       _builtin_protocol_features[indx].activation_block_num = current_block_num;
diff --git a/libraries/chain/resource_limits.cpp b/libraries/chain/resource_limits.cpp
index d98ca79fb..8b12fff7e 100644
--- a/libraries/chain/resource_limits.cpp
+++ b/libraries/chain/resource_limits.cpp
@@ -54,6 +54,12 @@ void resource_limits_manager::add_indices() {
 void resource_limits_manager::initialize_database() {
    const auto& config = _db.create<resource_limits_config_object>([](resource_limits_config_object& config){
       // see default settings in the declaration
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RLIMIT_OP CONFIG INS ${data}",
+            ("data", config)
+         );
+      }
    });
 
    _db.create<resource_limits_state_object>([&config](resource_limits_state_object& state){
@@ -62,6 +68,12 @@ void resource_limits_manager::initialize_database() {
       // start the chain off in a way that it is "congested" aka slow-start
       state.virtual_cpu_limit = config.cpu_limit_parameters.max;
       state.virtual_net_limit = config.net_limit_parameters.max;
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RLIMIT_OP STATE INS ${data}",
+            ("data", state)
+         );
+      }
    });
 }
 
@@ -91,10 +103,22 @@ void resource_limits_manager::read_from_snapshot( const snapshot_reader_ptr& sna
 void resource_limits_manager::initialize_account(const account_name& account) {
    _db.create<resource_limits_object>([&]( resource_limits_object& bl ) {
       bl.owner = account;
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RLIMIT_OP ACCOUNT_LIMITS INS ${data}",
+            ("data", bl)
+         );
+      }
    });
 
    _db.create<resource_usage_object>([&]( resource_usage_object& bu ) {
       bu.owner = account;
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RLIMIT_OP ACCOUNT_USAGE INS ${data}",
+            ("data", bu)
+         );
+      }
    });
 }
 
@@ -104,9 +128,16 @@ void resource_limits_manager::set_block_parameters(const elastic_limit_parameter
    const auto& config = _db.get<resource_limits_config_object>();
    if( config.cpu_limit_parameters == cpu_limit_parameters && config.net_limit_parameters == net_limit_parameters )
       return;
+
    _db.modify(config, [&](resource_limits_config_object& c){
       c.cpu_limit_parameters = cpu_limit_parameters;
       c.net_limit_parameters = net_limit_parameters;
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RLIMIT_OP CONFIG UPD ${data}",
+            ("data", c)
+         );
+      }
    });
 }
 
@@ -136,6 +167,12 @@ void resource_limits_manager::add_transaction_usage(const flat_set<account_name>
       _db.modify( usage, [&]( auto& bu ){
           bu.net_usage.add( net_usage, time_slot, config.account_net_usage_average_window );
           bu.cpu_usage.add( cpu_usage, time_slot, config.account_cpu_usage_average_window );
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog("RLIMIT_OP ACCOUNT_USAGE UPD ${data}",
+               ("data", bu)
+            );
+         }
       });
 
       if( cpu_weight >= 0 && state.total_cpu_weight > 0 ) {
@@ -187,7 +224,7 @@ void resource_limits_manager::add_transaction_usage(const flat_set<account_name>
    EOS_ASSERT( state.pending_net_usage <= config.net_limit_parameters.max, block_resource_exhausted, "Block has insufficient net resources" );
 }
 
-void resource_limits_manager::add_pending_ram_usage( const account_name account, int64_t ram_delta ) {
+void resource_limits_manager::add_pending_ram_usage( const account_name account, int64_t ram_delta, uint32_t action_id, const char* event_id, const char* family, const char* operation, const char* legacy_tag ) {
    if (ram_delta == 0) {
       return;
    }
@@ -201,6 +238,19 @@ void resource_limits_manager::add_pending_ram_usage( const account_name account,
 
    _db.modify( usage, [&]( auto& u ) {
      u.ram_usage += ram_delta;
+
+     if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RAM_OP ${action_id} ${event_id} ${family} ${operation} ${legacy_tag} ${payer} ${new_usage} ${delta}",
+            ("action_id", action_id)
+            ("event_id", event_id)
+            ("family", family)
+            ("operation", operation)
+            ("legacy_tag", legacy_tag)
+            ("payer", account)
+            ("new_usage", u.ram_usage)
+            ("delta", ram_delta)
+         );
+     }
    });
 }
 
@@ -266,6 +316,12 @@ bool resource_limits_manager::set_account_limits( const account_name& account, i
       pending_limits.ram_bytes = ram_bytes;
       pending_limits.net_weight = net_weight;
       pending_limits.cpu_weight = cpu_weight;
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RLIMIT_OP ACCOUNT_LIMITS UPD ${data}",
+            ("data", pending_limits)
+         );
+      }
    });
 
    return decreased_limit;
@@ -322,6 +378,12 @@ void resource_limits_manager::process_account_limit_updates() {
 
          multi_index.remove(*itr);
       }
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RLIMIT_OP STATE UPD ${data}",
+            ("data", state)
+         );
+      }
    });
 }
 
@@ -339,6 +401,11 @@ void resource_limits_manager::process_block_usage(uint32_t block_num) {
       state.update_virtual_net_limit(config);
       state.pending_net_usage = 0;
 
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+         dmlog("RLIMIT_OP STATE UPD ${data}",
+            ("data", state)
+         );
+      }
    });
 
 }
diff --git a/libraries/chain/transaction_context.cpp b/libraries/chain/transaction_context.cpp
index 8ec0d36e9..2f0075c32 100644
--- a/libraries/chain/transaction_context.cpp
+++ b/libraries/chain/transaction_context.cpp
@@ -556,9 +556,9 @@ namespace bacc = boost::accumulators;
       }
    }
 
-   void transaction_context::add_ram_usage( account_name account, int64_t ram_delta ) {
+   void transaction_context::add_ram_usage( account_name account, int64_t ram_delta, const char* event_id, const char* family, const char* operation, const char* legacy_tag ) {
       auto& rl = control.get_mutable_resource_limits_manager();
-      rl.add_pending_ram_usage( account, ram_delta );
+      rl.add_pending_ram_usage( account, ram_delta, action_id.current(), event_id, family, operation, legacy_tag );
       if( ram_delta > 0 ) {
          validate_ram_usage.insert( account );
       }
@@ -665,6 +665,13 @@ namespace bacc = boost::accumulators;
 
    void transaction_context::execute_action( uint32_t action_ordinal, uint32_t recurse_depth ) {
       apply_context acontext( control, *this, action_ordinal, recurse_depth );
+
+      if (eosio::chain::chain_config::deep_mind_enabled && recurse_depth == 0) {
+         dmlog("CREATION_OP ROOT ${action_id}",
+            ("action_id", action_id.current())
+         );
+      }
+
       acontext.exec();
    }
 
@@ -680,6 +687,7 @@ namespace bacc = boost::accumulators;
 
       auto first_auth = trx.first_authorizer();
 
+      fc::string event_id;
       uint32_t trx_size = 0;
       const auto& cgto = control.mutable_db().create<generated_transaction_object>( [&]( auto& gto ) {
         gto.trx_id      = id;
@@ -690,10 +698,26 @@ namespace bacc = boost::accumulators;
         gto.delay_until = gto.published + delay;
         gto.expiration  = gto.delay_until + fc::seconds(control.get_global_properties().configuration.deferred_trx_expiration_window);
         trx_size = gto.set( trx );
+
+        if (eosio::chain::chain_config::deep_mind_enabled) {
+            event_id = ramEventId("${id}", ("id", gto.id));
+
+            dmlog("DTRX_OP PUSH_CREATE ${action_id} ${sender} ${sender_id} ${payer} ${published} ${delay} ${expiration} ${trx_id} ${trx}",
+               ("action_id", action_id.current())
+               ("sender", gto.sender)
+               ("sender_id", gto.sender_id)
+               ("payer", gto.payer)
+               ("published", gto.published)
+               ("delay", gto.delay_until)
+               ("expiration", gto.expiration)
+               ("trx_id", trx.id())
+               ("trx", control.to_variant_with_abi(trx, fc::microseconds(5000000)))
+            );
+         }
       });
 
       int64_t ram_delta = (config::billable_size_v<generated_transaction_object> + trx_size);
-      add_ram_usage( cgto.payer, ram_delta );
+      add_ram_usage( cgto.payer, ram_delta, event_id.c_str(), "deferred_trx", "push", "deferred_trx_pushed" );
       trace->account_ram_delta = account_delta( cgto.payer, ram_delta );
    }
 
diff --git a/libraries/chain/wasm_interface.cpp b/libraries/chain/wasm_interface.cpp
index 4bf4ec70e..19cf2a2e1 100644
--- a/libraries/chain/wasm_interface.cpp
+++ b/libraries/chain/wasm_interface.cpp
@@ -150,7 +150,7 @@ class privileged_api : public context_aware_api {
        *  Also fails if the feature was already activated or pre-activated.
        */
       void preactivate_feature( const digest_type& feature_digest ) {
-         context.control.preactivate_feature( feature_digest );
+         context.control.preactivate_feature( context.trx_context.action_id.current(), feature_digest );
       }
 
       /**
@@ -1085,7 +1085,7 @@ class console_api : public context_aware_api {
    public:
       console_api( apply_context& ctx )
       : context_aware_api(ctx,true)
-      , ignore(!ctx.control.contracts_console()) {}
+      , ignore(!eosio::chain::chain_config::deep_mind_console_enabled) {}
 
       // Kept as intrinsic rather than implementing on WASM side (using prints_l and strlen) because strlen is faster on native side.
       void prints(null_terminated_ptr str) {
diff --git a/plugins/chain_plugin/chain_plugin.cpp b/plugins/chain_plugin/chain_plugin.cpp
index 596edf733..fda8a7130 100644
--- a/plugins/chain_plugin/chain_plugin.cpp
+++ b/plugins/chain_plugin/chain_plugin.cpp
@@ -207,6 +207,13 @@ chain_plugin::~chain_plugin(){}
 void chain_plugin::set_program_options(options_description& cli, options_description& cfg)
 {
    cfg.add_options()
+         ("schnapps-enable", bpo::bool_switch()->default_value(false),
+          "Create automatic snapshots when replaying from block log at regular interval controlled by schnapps-block-frequency")
+         ("schnapps-block-interval", bpo::value<uint32_t>()->default_value(50000),
+          "Block frequency at which snapshots should be taken when performing replay from block log")
+         ("schnapps-snapshots-path", bpo::value<bfs::path>(),
+          "Block frequency at which snapshots should be taken when performing replay from block log")
+
          ("blocks-dir", bpo::value<bfs::path>()->default_value("blocks"),
           "the location of the blocks directory (absolute path or relative to application data dir)")
          ("protocol-features-dir", bpo::value<bfs::path>()->default_value("protocol_features"),
@@ -225,6 +232,12 @@ void chain_plugin::set_program_options(options_description& cli, options_descrip
           "Number of worker threads in controller thread pool")
          ("contracts-console", bpo::bool_switch()->default_value(false),
           "print contract's output to console")
+         ("deep-mind", bpo::bool_switch()->default_value(false),
+          "print deeper information about eosio software")
+         ("deep-mind-console", bpo::bool_switch()->default_value(false),
+          "add smart contract console logging to deep mind")
+         ("deep-mind-subjective-mitigations-disabled", bpo::bool_switch()->default_value(false),
+          "disable all subjectives mitigations so you can still create now impossible transaction")
          ("actor-whitelist", boost::program_options::value<vector<string>>()->composing()->multitoken(),
           "Account added to actor whitelist (may specify multiple times)")
          ("actor-blacklist", boost::program_options::value<vector<string>>()->composing()->multitoken(),
@@ -305,7 +318,6 @@ void chain_plugin::set_program_options(options_description& cli, options_descrip
            "export reversible block database in portable format into specified file and then exit")
          ("snapshot", bpo::value<bfs::path>(), "File to read Snapshot State from")
          ;
-
 }
 
 #define LOAD_VALUE_SET(options, name, container) \
@@ -564,6 +576,10 @@ void chain_plugin::plugin_initialize(const variables_map& options) {
          throw;
       }
 
+      eosio::chain::chain_config::deep_mind_enabled = options.at( "deep-mind" ).as<bool>();
+      eosio::chain::chain_config::deep_mind_console_enabled = options.at( "deep-mind-console" ).as<bool>();
+      eosio::chain::chain_config::deep_mind_subjective_mitigations_disabled = options.at( "deep-mind-subjective-mitigations-disabled" ).as<bool>();
+
       my->chain_config = controller::config();
 
       LOAD_VALUE_SET( options, "sender-bypass-whiteblacklist", my->chain_config->sender_bypass_whiteblacklist );
@@ -784,6 +800,29 @@ void chain_plugin::plugin_initialize(const variables_map& options) {
          wlog("The --import-reversible-blocks option should be used by itself.");
       }
 
+      if( options.count( "schnapps-enable" )) {
+         my->chain_config->schnapps_enable = options.at( "schnapps-enable" ).as<bool>();
+      }
+
+      if( options.count( "schnapps-block-interval" )) {
+         my->chain_config->schnapps_block_interval = options.at( "schnapps-block-interval" ).as<uint32_t>();
+      }
+
+      if( options.count( "schnapps-snapshots-path" )) {
+         auto sd = options.at( "schnapps-snapshots-path" ).as<bfs::path>();
+         if( sd.is_relative()) {
+            my->chain_config->schnapps_snapshots_path = app().data_dir() / sd;
+            if (!fc::exists(my->chain_config->schnapps_snapshots_path)) {
+               fc::create_directories(my->chain_config->schnapps_snapshots_path);
+            }
+         } else {
+            my->chain_config->schnapps_snapshots_path = sd;
+         }
+
+         EOS_ASSERT( fc::is_directory(my->chain_config->schnapps_snapshots_path), snapshot_directory_not_found_exception,
+                     "No such directory '${dir}'", ("dir", my->chain_config->schnapps_snapshots_path.generic_string()) );
+      }
+
       if (options.count( "snapshot" )) {
          my->snapshot_path = options.at( "snapshot" ).as<bfs::path>();
          EOS_ASSERT( fc::exists(*my->snapshot_path), plugin_config_exception,
@@ -937,6 +976,13 @@ void chain_plugin::plugin_initialize(const variables_map& options) {
             } );
 
       my->accepted_block_connection = my->chain->accepted_block.connect( [this]( const block_state_ptr& blk ) {
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog("ACCEPTED_BLOCK ${num} ${blk}",
+               ("num", blk->block_num)
+               ("blk", chain().to_variant_with_abi(blk, fc::microseconds(5000000)))
+            );
+         }
+
          my->accepted_block_channel.publish( priority::high, blk );
       } );
 
@@ -951,6 +997,13 @@ void chain_plugin::plugin_initialize(const variables_map& options) {
 
       my->applied_transaction_connection = my->chain->applied_transaction.connect(
             [this]( std::tuple<const transaction_trace_ptr&, const signed_transaction&> t ) {
+               if (eosio::chain::chain_config::deep_mind_enabled) {
+                  dmlog("APPLIED_TRANSACTION ${block} ${traces}",
+                     ("block", chain().head_block_num() + 1)
+                     ("traces", chain().to_variant_with_abi(std::get<0>(t), fc::microseconds(5000000)))
+                  );
+               }
+
                my->applied_transaction_channel.publish( priority::low, std::get<0>(t) );
             } );
 
@@ -989,6 +1042,7 @@ void chain_plugin::plugin_startup()
 } FC_CAPTURE_AND_RETHROW() }
 
 void chain_plugin::plugin_shutdown() {
+   ilog("chain shutdown");
    my->pre_accepted_block_connection.reset();
    my->accepted_block_header_connection.reset();
    my->accepted_block_connection.reset();
@@ -998,6 +1052,7 @@ void chain_plugin::plugin_shutdown() {
    if(app().is_quiting())
       my->chain->get_wasm_interface().indicate_shutting_down();
    my->chain.reset();
+   ilog("chain done");
 }
 
 chain_apis::read_write::read_write(controller& db, const fc::microseconds& abi_serializer_max_time)
diff --git a/unittests/resource_limits_test.cpp b/unittests/resource_limits_test.cpp
index 9040c5bdc..9431a546a 100644
--- a/unittests/resource_limits_test.cpp
+++ b/unittests/resource_limits_test.cpp
@@ -253,11 +253,11 @@ BOOST_AUTO_TEST_SUITE(resource_limits_test)
       process_account_limit_updates();
 
       for (uint64_t idx = 0; idx < expected_iterations - 1; idx++) {
-         add_pending_ram_usage(account, increment);
+         add_pending_ram_usage(account, increment, 0, "test", "test", "test", "test");
          verify_account_ram_usage(account);
       }
 
-      add_pending_ram_usage(account, increment);
+      add_pending_ram_usage(account, increment, 0, "test", "test", "test", "test");
       BOOST_REQUIRE_THROW(verify_account_ram_usage(account), ram_usage_exceeded);
    } FC_LOG_AND_RETHROW();
 
@@ -267,7 +267,7 @@ BOOST_AUTO_TEST_SUITE(resource_limits_test)
       set_account_limits(account, 100, -1, -1 );
       verify_account_ram_usage(account);
       process_account_limit_updates();
-      BOOST_REQUIRE_THROW(add_pending_ram_usage(account, -101), transaction_exception);
+      BOOST_REQUIRE_THROW(add_pending_ram_usage(account, -101, 0, "test", "test", "test", "test"), transaction_exception);
 
    } FC_LOG_AND_RETHROW();
 
@@ -277,11 +277,11 @@ BOOST_AUTO_TEST_SUITE(resource_limits_test)
       set_account_limits(account, UINT64_MAX, -1, -1 );
       verify_account_ram_usage(account);
       process_account_limit_updates();
-      add_pending_ram_usage(account, UINT64_MAX/2);
+      add_pending_ram_usage(account, UINT64_MAX/2, 0, "test", "test", "test", "test");
       verify_account_ram_usage(account);
-      add_pending_ram_usage(account, UINT64_MAX/2);
+      add_pending_ram_usage(account, UINT64_MAX/2, 0, "test", "test", "test", "test");
       verify_account_ram_usage(account);
-      BOOST_REQUIRE_THROW(add_pending_ram_usage(account, 2), transaction_exception);
+      BOOST_REQUIRE_THROW(add_pending_ram_usage(account, 2, 0, "test", "test", "test", "test"), transaction_exception);
 
    } FC_LOG_AND_RETHROW();
 
@@ -296,7 +296,7 @@ BOOST_AUTO_TEST_SUITE(resource_limits_test)
       initialize_account(account);
       set_account_limits(account, limit, -1, -1 );
       process_account_limit_updates();
-      add_pending_ram_usage(account, commit);
+      add_pending_ram_usage(account, commit, 0, "test", "test", "test", "test");
       verify_account_ram_usage(account);
 
       for (int idx = 0; idx < expected_iterations - 1; idx++) {
@@ -333,6 +333,6 @@ BOOST_AUTO_TEST_SUITE(resource_limits_test)
 
 
 
-   } FC_LOG_AND_RETHROW() 
+   } FC_LOG_AND_RETHROW()
 
 BOOST_AUTO_TEST_SUITE_END()
